"""Configuration management for odin-bots.

Loads configuration from odin-bots.toml in the project root.
"""

import os
from pathlib import Path
from typing import Optional

import tomllib


# ---------------------------------------------------------------------------
# Network & canister constants
# ---------------------------------------------------------------------------

IC_HOST = "https://ic0.app"

# onicai ckSigner canister (prd, fiduciary subnet)
ONICAI_CKSIGNER_CANISTER_ID = "g7qkb-iiaaa-aaaar-qb3za-cai"

# Odin.fun SIWB canister (Sign-In with Bitcoin)
ODIN_SIWB_CANISTER_ID = "bcxqa-kqaaa-aaaak-qotba-cai"

# ckBTC ledger
CKBTC_LEDGER_CANISTER_ID = "mxzaz-hqaaa-aaaar-qaada-cai"

# ckBTC minter (BTC <-> ckBTC)
CKBTC_MINTER_CANISTER_ID = "mqygn-kiaaa-aaaar-qaadq-cai"

# Odin.fun trading canister
ODIN_TRADING_CANISTER_ID = "z2vm5-gaaaa-aaaaj-azw6q-cai"

# Odin.fun ckBTC deposit helper
ODIN_DEPOSIT_CANISTER_ID = "ztwhb-qiaaa-aaaaj-azw7a-cai"

# Odin.fun API
ODIN_API_URL = "https://api.odin.fun/v1"

# ---------------------------------------------------------------------------
# Trading limits (enforced by Odin.fun trading canister)
# ---------------------------------------------------------------------------

MIN_DEPOSIT_SATS = 5000   # minimum ckBTC deposit into Odin.Fun
MIN_TRADE_SATS = 500      # minimum BTC-equivalent for buy/sell on Odin.Fun
MIN_BTC_WITHDRAWAL_SATS = 50_000  # minimum BTC withdrawal via ckBTC minter

# ---------------------------------------------------------------------------
# BTC/USD rate & sats formatting
# ---------------------------------------------------------------------------

def get_btc_to_usd_rate() -> float:
    """Get the current BTC to USD exchange rate from Coinbase."""
    import requests
    url = "https://api.coinbase.com/v2/exchange-rates?currency=BTC"
    response = requests.get(url, timeout=30)
    response.raise_for_status()
    data = response.json()
    return float(data["data"]["rates"]["USD"])


def fmt_sats(sats, btc_usd_rate) -> str:
    """Format sats with optional USD value.

    Args:
        sats: Amount in satoshis.
        btc_usd_rate: BTC/USD rate, or None to skip USD.
    """
    if btc_usd_rate:
        usd = (sats / 100_000_000) * btc_usd_rate
        return f"{sats:,} sats (${usd:.2f})"
    return f"{sats:,} sats"


# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------

# PEM file path (always .wallet/identity-private.pem, generated by: odin-bots wallet create)
PEM_FILE = ".wallet/identity-private.pem"

DEFAULT_CONFIG = {
    "settings": {},
    "bots": {
        "bot-1": {"description": "Bot 1"},
    },
}

CONFIG_FILENAME = "odin-bots.toml"

# Module-level cache
_cached_config: Optional[dict] = None
_cached_config_path: Optional[Path] = None

# Module-level verbose flag (controlled by CLI --verbose in the future)
_verbose: bool = True


def set_verbose(enabled: bool) -> None:
    """Set the global verbose flag."""
    global _verbose
    _verbose = enabled


def is_verbose() -> bool:
    """Return the current verbose flag."""
    return _verbose


def log(msg: str) -> None:
    """Print a message if verbose mode is enabled."""
    if _verbose:
        print(msg)


def _project_root() -> str:
    """Return the odin_bots project root directory.

    Resolution order:
    1. ODIN_BOTS_ROOT environment variable (if set)
    2. Current working directory
    """
    return os.environ.get("ODIN_BOTS_ROOT", os.environ.get("PWD", os.getcwd()))


def find_config() -> Optional[Path]:
    """Find odin-bots.toml in cwd or ODIN_BOTS_ROOT.

    Returns:
        Path to config file if found, None otherwise.
    """
    root = Path(_project_root())
    config_path = root / CONFIG_FILENAME
    if config_path.exists():
        return config_path
    return None


def load_config(reload: bool = False) -> dict:
    """Load config from odin-bots.toml or return defaults.

    Args:
        reload: If True, reload config even if cached.

    Returns:
        Configuration dictionary with settings and bots.
    """
    global _cached_config, _cached_config_path

    if _cached_config is not None and not reload:
        return _cached_config

    config_path = find_config()

    if config_path is None:
        _cached_config = DEFAULT_CONFIG.copy()
        _cached_config_path = None
        return _cached_config

    with open(config_path, "rb") as f:
        config = tomllib.load(f)

    # Merge with defaults for missing keys
    result = DEFAULT_CONFIG.copy()
    if "settings" in config:
        result["settings"] = {**DEFAULT_CONFIG["settings"], **config["settings"]}
    if "bots" in config:
        result["bots"] = config["bots"]

    _cached_config = result
    _cached_config_path = config_path
    return result


def get_config_path() -> Optional[Path]:
    """Return the path to the loaded config file, or None if using defaults."""
    load_config()  # Ensure config is loaded
    return _cached_config_path


def get_pem_file() -> str:
    """Return the absolute path to the PEM file."""
    return os.path.join(_project_root(), PEM_FILE)


def require_wallet() -> bool:
    """Check that the wallet PEM exists. Print instructions and return False if not."""
    pem_path = get_pem_file()
    if os.path.exists(pem_path):
        return True
    print("No odin-bots wallet found in current directory. Set it up first:\n")
    print("  odin-bots wallet create")
    print("  odin-bots wallet receive   # shows how to fund your odin bots")
    print()
    print(f"  (expected PEM at {pem_path})")
    return False


def get_cache_sessions() -> bool:
    """Return whether session caching to disk is enabled.

    Reads `cache_sessions` from [settings] in odin-bots.toml.
    Defaults to True. When False, sessions are not written to disk
    and a fresh SIWB login is performed for every command.
    """
    config = load_config()
    return config.get("settings", {}).get("cache_sessions", True)


def get_verify_certificates() -> bool:
    """Return whether IC certificate verification is enabled.

    Reads `verify_certificates` from [settings] in odin-bots.toml.
    Defaults to False (blst not required for basic usage).
    When True, requires the blst library to be installed.
    """
    config = load_config()
    enabled = config.get("settings", {}).get("verify_certificates", False)
    if enabled:
        try:
            import blst  # noqa: F401
        except ImportError:
            print("Error: verify_certificates = true in odin-bots.toml,")
            print("but the 'blst' library is not installed.")
            print()
            print("See README-security.md for installation instructions.")
            raise SystemExit(1)
    return enabled


def get_bot_names() -> list[str]:
    """Return list of configured bot names."""
    config = load_config()
    return list(config["bots"].keys())


def get_bot_description(bot_name: str) -> str:
    """Return the description for a bot, or empty string if not found."""
    config = load_config()
    bot = config["bots"].get(bot_name, {})
    return bot.get("description", "")


def validate_bot_name(name: str) -> bool:
    """Check if bot name exists in config.

    Note: Any non-empty string is valid as a bot name (derivation path).
    This just checks if it's explicitly configured.
    """
    config = load_config()
    return name in config["bots"]


def create_default_config(bot_name: str = "bot-1") -> str:
    """Generate default config file content.

    Args:
        bot_name: Name for the default bot.

    Returns:
        TOML content as string.
    """
    return f'''# odin-bots configuration
# See: https://github.com/onicai/odin_bots

[settings]
# See README-security.md for details
verify_certificates = false
cache_sessions = true

# Bot definitions
# Each bot gets its own trading identity on Odin.Fun.
[bots.{bot_name}]
description = "Bot 1"

[bots.bot-2]
description = "Bot 2"

[bots.bot-3]
description = "Bot 3"
'''
